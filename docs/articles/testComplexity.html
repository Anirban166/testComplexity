<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>General Vignette • testComplexity</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/sandstone/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><!-- docsearch --><script src="../docsearch.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.3/docsearch.min.css" integrity="sha256-QOSRU/ra9ActyXkIBbiIB144aDBdtvXBcNc3OTNuX/Q=" crossorigin="anonymous">
<link href="../docsearch.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script><meta property="og:title" content="General Vignette">
<meta property="og:description" content="testComplexity">
<meta name="robots" content="noindex">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">testComplexity</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/testComplexity.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/cDPA.html">PeakSegDP::cDPA(), a quadratic time constrained dynamic programming algorithm</a>
    </li>
    <li>
      <a href="../articles/fpop.html">fpop::Fpop(), a log-linear time segmentation algorithm</a>
    </li>
    <li>
      <a href="../articles/gfpop.html">gfpop::gfpop(), a log-linear time algorithm for constrained changepoint detection</a>
    </li>
    <li>
      <a href="../articles/opart.html">opart::gaussian(), a quadratic time optimal partioning algorithm</a>
    </li>
    <li>
      <a href="../articles/PeakSegPDPA.html">PeakSegOptimal::PeakSegPDPA(), a log-linear time algorithm for constrained changepoint detection</a>
    </li>
    <li>
      <a href="../articles/PELT_and_SegNeigh.html">PELT and SegNeigh algorithms for changepoint::cpt.mean()</a>
    </li>
    <li>
      <a href="../articles/substring_and_gregexpr.html">Quadratic to linear transition for substring() and gregexpr()</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/Anirban166/testComplexity">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
<form class="navbar-form navbar-right hidden-xs hidden-sm" role="search">
        <div class="form-group">
          <input type="search" class="form-control" name="search-input" id="search-input" placeholder="Search..." aria-label="Search for..." autocomplete="off">
</div>
      </form>
      
    </div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>General Vignette</h1>
                        <h4 class="author">Anirban Chetia</h4>
            
            <h4 class="date">2020-08-29</h4>
      
      
      <div class="hidden name"><code>testComplexity.Rmd</code></div>

    </div>

    
    
<p style="font-family: times, serif; font-size:25pt; font-style: italic" align="center">
Welcome to testComplexity!
</p>
<hr>
<p>This vignette is written to give the user a general introduction to the features and functionality of the package, via a set of textual elucidations and one example discussed throughout for each of the user-oriented functions.</p>
<div id="brief-overview" class="section level2">
<h2 class="hasAnchor">
<a href="#brief-overview" class="anchor"></a>Brief Overview</h2>
<p>As can be guessed from the name itself, this package provides a suite of functions to systematically test the asymptotic complexities of R functions/algorithms, where the term “complexity” here refers to the <strong>time</strong> complexity, as per the initial idea. (and hence a relevant logo with the stopwatch was designed early on!)</p>
<div id="features" class="section level3">
<h3 class="hasAnchor">
<a href="#features" class="anchor"></a>Features</h3>
<p>Going by the base objectives stated <a href="https://github.com/rstats-gsoc/gsoc2020/wiki/Asymptotic-complexity-testing#details-of-your-coding-project">here</a>, this package provides:</p>
<ul>
<li>A <a href="https://anirban166.github.io/testComplexity/reference/asymptoticTimings.html">function</a> for quantifying the empirical time complexity of any R expression.</li>
<li>A time complexity classifying <a href="https://anirban166.github.io/testComplexity/reference/asymptoticTimeComplexityClass.html">function</a> which operates on the result (a data frame) of the previous function.</li>
<li>Testing <a href="https://anirban166.github.io/testComplexity/reference/index.html#section-testers">functions</a>, to test for an expected time complexity class directly.</li>
</ul>
<p>In addition to these, a few more features have been implemented:</p>
<ul>
<li>A <a href="https://anirban166.github.io/testComplexity/reference/asymptoticMemoryUsage.html">function</a> for quantifying memory allocations and <a href="https://anirban166.github.io/testComplexity/reference/asymptoticMemoryComplexityClass.html">one</a> for subsequently classifying the space/memory complexity.</li>
<li>Plotting <a href="https://anirban166.github.io/testComplexity/reference/index.html#section-plotters">functions</a> for both time and memory cases.</li>
<li>A complexity <a href="https://anirban166.github.io/testComplexity/reference/asymptoticComplexityClass.html">classifier</a> for generalized use in asymptotic trend classification among any two parameters, not being restricted to time/memory cases.</li>
</ul>
<hr>
</div>
<div id="usage-notes" class="section level3">
<h3 class="hasAnchor">
<a href="#usage-notes" class="anchor"></a>Usage Notes</h3>
<p>Based on whether the user has an idea of the complexity class the input algorithm falls in, two scenarios are possible:</p>
<ul>
<li>The complexity class of the algorithm is <em>not known</em>, or diagnostic tests to estimate it have not been performed yet. In this case, the user could directly use the <a href="https://anirban166.github.io/testComplexity/articles/Example.html#quantifiers">quantifiers</a> and <a href="https://anirban166.github.io/testComplexity/articles/Example.html#complexity-classifiers">complexity classifiers</a> to obtain the asymptotic complexity class.</li>
<li>The complexity class is <em>known</em> via theoretical proof/empirical observation. For this case, the user can directly proceed to use the <a href="https://anirban166.github.io/testComplexity/articles/Example.html#testers">testers</a> for verifying the theoretically-derived/empirically-obtained result, apart from using the previous method.</li>
</ul>
<p>Note that the worst-case complexity class is currently set to quadratic. Cubic and exponential classes were initially thought of to be included, but since a <span class="math inline">\(O(N^2)\)</span> approach is the limit in practically used algorithms, subsequently higher complexity classes were discarded.</p>
<p>If the estimated complexity class turns out to be quadratic, its an indicator that the algorithm could do with a better approach, so as to minimize the computational resources (time/memory).</p>
<p>In such situations, the user may as well want to think of ways to reduce the time complexity, in which case the aforementioned functions will be helpful to continuously give feedback (via re-runs) for each improvement that the user thinks could make a difference in the complexity trend. This in turn could potentially lead to improvements in code performance, if such feedback-based optimizations are implemented in order to achieve better computational efficiency.</p>
<hr>
</div>
</div>
<div id="examples" class="section level2">
<h2 class="hasAnchor">
<a href="#examples" class="anchor"></a>Examples</h2>
<p>To demonstrate the functionality of our package, I’ll be taking the function <a href="https://github.com/tdhock/PeakSegOptimal/blob/master/R/PeakSegPDPA.R"><code>PeakSegPDPA</code></a> from the <a href="https://github.com/tdhock/PeakSegOptimal"><code>PeakSegOptimal</code></a> package as an example for each of the functions stated below. Note that it is empirically observed to be a log-linear time and memory algorithm, or the expected complexity classes for both time and memory cases is <span class="math inline">\(O(NlogN)\)</span> for input size <span class="math inline">\(N\)</span>. This fact here is essential to know before-hand as you’ll see<sup>1</sup> that testComplexity’s functions obtain the same result, demonstrating its accuracy.</p>
<div id="function-categories" class="section level3">
<h3 class="hasAnchor">
<a href="#function-categories" class="anchor"></a>Function Categories</h3>
<p>Based on the different aspects of functionality, the functions in this package can be grouped into four distinct categories:</p>
</div>
<div id="quantifiers" class="section level3">
<h3 class="hasAnchor">
<a href="#quantifiers" class="anchor"></a><a href="https://anirban166.github.io/testComplexity/reference/index.html#section-quantifiers">Quantifiers</a>
</h3>
<p>These are the quantifying functions which compute the empirical benchmarks for runtimes (via the <code><a href="../reference/asymptoticTimings.html">asymptoticTimings()</a></code> function) and memory allocations (via the <code><a href="../reference/asymptoticMemoryUsage.html">asymptoticMemoryUsage()</a></code> function) against allotted data sizes. For user convenience, a few points have been taken note of with respect to the parameters:</p>
<ul>
<li><p>The user-supplied algorithm is ideally accepted as an expression, which would be a function that scales with <code>N</code> (as a parameter) so as to comply with the general notation of <code>N</code> resembling the input size when we refer to asymptotic complexity classes (such as <span class="math inline">\(O(N)\)</span> denoting the linear variant, or a linear asymptotic trend in <span class="math inline">\(N\)</span>). The values which <code>N</code> can take are seperately specified by the vector/set of user-provided values for the argument <code>data.sizes</code>.</p></li>
<li><p>Parameters such as <code>max.bytes</code> and <code>max.seconds</code> are introduced to put a desirable restriction on the time invested and memory allocated respectively, thereby saving resources (time/memory) for the otherwise possible further computation once the limit has been breached. The default values have been set taking into account the correct prediction for different test-cases, and should enact as an appropriate threshold for most algorithms.</p></li>
</ul>
<p>The only requirement for the user is to be able to identify the parameter in his/her <em>own</em> function/algorithm which can scale asymptotically for different data sizes, or in simple terms the parameter which can contain different values and the function’s resource utilization varies depending on that. (which is fairly easy to figure out and is expected from the user)</p>
<p>To demonstrate the working, let us consider the example function <code><a href="https://rdrr.io/pkg/PeakSegOptimal/man/PeakSegPDPA.html">PeakSegOptimal::PeakSegPDPA()</a></code> and its parameters:</p>
<ul>
<li>
<code>count.vec</code>: It should be an integer vector of count data.</li>
<li>
<code>weight.vec</code>: Its a numeric vector of positive weights, which would be computed via <code>count.vec</code> automatically from the default assignment. (doesn’t need to be specified)</li>
<li>
<code>max.integer</code>: Maximum number of integer segments, which should be &gt;=2 in value.</li>
</ul>
<p>From the list of parameters above, the <code>count.vec</code> parameter is the one which when adjusted with higher values results in greater resource (time/memory) consumption, scaling asymptotically. Now in accordance with the first point mentioned above, we need to have that input vector of data as a function of <code>N</code>, which is relatively straight-forward depending on what type of data the function operates on. As per the function’s description, it states that the algorithm computes optimal changepoint models using the <em>Poisson</em> likelihood for non-negative count data, which means we need to create a vector of poisson data in <code>N</code>, which is as simple as:</p>
<div class="sourceCode" id="cb1"><html><body><pre class="r"><span class="no">data.vec</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Poisson.html">rpois</a></span>(<span class="no">N</span>, <span class="fl">1</span>)</pre></body></html></div>
<p>Now we simply emplace that function with its parameters for our expression argument in <code><a href="../reference/asymptoticTimings.html">asymptoticTimings()</a></code> and <code><a href="../reference/asymptoticMemoryUsage.html">asymptoticMemoryUsage()</a></code>, along with suitable data sizes to obtain the quantified timings/memory allocations respectively:</p>
<div class="sourceCode" id="cb2"><html><body><pre class="r"><span class="no">df.time</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/asymptoticTimings.html">asymptoticTimings</a></span>(<span class="kw">e</span> <span class="kw">=</span> <span class="kw pkg">PeakSegOptimal</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/PeakSegOptimal/man/PeakSegPDPA.html">PeakSegPDPA</a></span>(<span class="kw">count.vec</span> <span class="kw">=</span> <span class="no">data.vec</span>, <span class="kw">max.segments</span> <span class="kw">=</span> <span class="fl">3L</span>), <span class="kw">data.sizes</span> <span class="kw">=</span> <span class="fl">10</span>^<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fl">4</span>, <span class="kw">by</span> <span class="kw">=</span> <span class="fl">0.1</span>))
<span class="kw pkg">data.table</span><span class="kw ns">::</span><span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/data.table.html">data.table</a></span>(<span class="no">df.time</span>)
<span class="co">#&gt;       Timings Data sizes</span>
<span class="co">#&gt;  1:    248701         10</span>
<span class="co">#&gt;  2:    120302         10</span>
<span class="co">#&gt;  3:    125701         10</span>
<span class="co">#&gt;  4:    133301         10</span>
<span class="co">#&gt;  5:    146500         10</span>
<span class="co">#&gt; ---                     </span>
<span class="co">#&gt; 696: 405597501      10000</span>
<span class="co">#&gt; 697: 408335001      10000</span>
<span class="co">#&gt; 698: 338544401      10000</span>
<span class="co">#&gt; 699: 404081901      10000</span>
<span class="co">#&gt; 700: 399575501      10000</span></pre></body></html></div>
<div class="sourceCode" id="cb3"><html><body><pre class="r"><span class="no">df.memory</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/asymptoticMemoryUsage.html">asymptoticMemoryUsage</a></span>(<span class="kw pkg">PeakSegOptimal</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/PeakSegOptimal/man/PeakSegPDPA.html">PeakSegPDPA</a></span>(<span class="kw">count.vec</span> <span class="kw">=</span> <span class="no">data.vec</span>, <span class="kw">max.segments</span> <span class="kw">=</span> <span class="fl">3L</span>), <span class="kw">data.sizes</span> <span class="kw">=</span> <span class="fl">10</span>^<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fl">4</span>, <span class="kw">by</span> <span class="kw">=</span> <span class="fl">0.1</span>))
<span class="kw pkg">data.table</span><span class="kw ns">::</span><span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/data.table.html">data.table</a></span>(<span class="no">df.memory</span>)
<span class="co">#&gt;    Memory usage Data sizes</span>
<span class="co">#&gt; 1:         6256   10.00000</span>
<span class="co">#&gt; 2:         7024   12.58925</span>
<span class="co">#&gt; 3:         7432   15.84893</span>
<span class="co">#&gt; 4:         8560   19.95262</span>
<span class="co">#&gt; 5:         9496   25.11886</span>
<span class="co">#&gt; --- </span>
<span class="co">#&gt; 25:       447792 2511.88643</span>
<span class="co">#&gt; 26:       562336 3162.27766</span>
<span class="co">#&gt; 27:       706512 3981.07171</span>
<span class="co">#&gt; 28:       887792 5011.87234</span>
<span class="co">#&gt; 29:      1116240 6309.57344</span></pre></body></html></div>
<p>If the seperate use of <code>N</code> in the step-wise argument construction for the above demonstration seems confusing, one can simply pass the parameters directly like <code>count.vec = rpois(N, 1)</code> (avoiding use of <code>data.vec</code>) or just <code><a href="https://rdrr.io/r/stats/Poisson.html">rpois(N, 1)</a></code> (passing arguments in order).</p>
<p>Now that we have obtained our benchmarked data (consisting of runtimes and memory allocations) in a convienent <code>data.frame</code> format, we can proceed to find out the complexity class as demonstrated below.</p>
</div>
<div id="complexity-classifiers" class="section level3">
<h3 class="hasAnchor">
<a href="#complexity-classifiers" class="anchor"></a><a href="https://anirban166.github.io/testComplexity/reference/index.html#section-complexity-classifiers">Complexity Classifiers</a>
</h3>
<p>These are the complexity classification functions which internally use different stochastic procedures (such as cross-validation on different glm models, as derived from GuessCompx) to compute the complexity class for the user-provided algorithm via a best model match. Using them is relatively quite simple, as one just needs to pass the data frame obtained from the quantifiers to the appropriate complexity classifier.</p>
<p>As an example, consider the data frames we obtained above for our function <code><a href="https://rdrr.io/pkg/PeakSegOptimal/man/PeakSegPDPA.html">PeakSegOptimal::PeakSegPDPA()</a></code> and pass them onto the complexity classifiers <code><a href="../reference/asymptoticTimeComplexityClass.html">asymptoticTimeComplexityClass()</a></code> and <code><a href="../reference/asymptoticMemoryComplexityClass.html">asymptoticMemoryComplexityClass()</a></code> for time and memory cases respectively:</p>
<div class="sourceCode" id="cb4"><html><body><pre class="r"><span class="fu"><a href="../reference/asymptoticTimeComplexityClass.html">asymptoticTimeComplexityClass</a></span>(<span class="no">df.time</span>)
<span class="co">#&gt; [1] "loglinear"</span></pre></body></html></div>
<div class="sourceCode" id="cb5"><html><body><pre class="r"><span class="fu"><a href="../reference/asymptoticMemoryComplexityClass.html">asymptoticMemoryComplexityClass</a></span>(<span class="no">df.memory</span>)
<span class="co">#&gt; [1] "loglinear"</span></pre></body></html></div>
<p>The resulting complexity classes turned out to be log-linear for both time and memory cases, (coincidentally for this function they are the same) which are exactly<sup>1</sup> the expected complexity classes.</p>
<p>Note that you can chain the quantifiers with them, or call them and operate on their returned data frames directly:</p>
<div class="sourceCode" id="cb6"><html><body><pre class="r"><span class="fu"><a href="../reference/asymptoticTimeComplexityClass.html">asymptoticTimeComplexityClass</a></span>(<span class="fu"><a href="../reference/asymptoticTimings.html">asymptoticTimings</a></span>(<span class="kw">e</span> <span class="kw">=</span> <span class="kw pkg">PeakSegOptimal</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/PeakSegOptimal/man/PeakSegPDPA.html">PeakSegPDPA</a></span>(<span class="kw">count.vec</span> <span class="kw">=</span> <span class="no">data.vec</span>, <span class="kw">max.segments</span> <span class="kw">=</span> <span class="fl">3L</span>), <span class="kw">data.sizes</span> <span class="kw">=</span> <span class="fl">10</span>^<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fl">4</span>, <span class="kw">by</span> <span class="kw">=</span> <span class="fl">0.1</span>)))
<span class="co">#&gt; [1] "loglinear"</span>
<span class="fu"><a href="../reference/asymptoticMemoryComplexityClass.html">asymptoticMemoryComplexityClass</a></span>(<span class="fu"><a href="../reference/asymptoticMemoryUsage.html">asymptoticMemoryUsage</a></span>(<span class="kw pkg">PeakSegOptimal</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/PeakSegOptimal/man/PeakSegPDPA.html">PeakSegPDPA</a></span>(<span class="kw">count.vec</span> <span class="kw">=</span> <span class="no">data.vec</span>, <span class="kw">max.segments</span> <span class="kw">=</span> <span class="fl">3L</span>), <span class="kw">data.sizes</span> <span class="kw">=</span> <span class="fl">10</span>^<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fl">4</span>, <span class="kw">by</span> <span class="kw">=</span> <span class="fl">0.1</span>)))
<span class="co">#&gt; [1] "loglinear"</span></pre></body></html></div>
<p>Furthermore, if the user wants to classify the asymptotic trend between two custom parameters (which are not subject to being only runtimes/memory-allocations), they can use the <code><a href="../reference/asymptoticComplexityClass.html">asymptoticComplexityClass()</a></code> function which as intended, computes the complexity class based on the trend followed between any two parameters of user-provided data which are contained in a data frame.</p>
<p>The function accepts a data frame along with the two columnar parameters which the user needs to specify (as to which designates the output metric and which designates the data sizes, or something to relatively measure the trend against).</p>
<p>Note that since the computed data is already prevalent in the specified output parameter column of the data frame, we don’t need to use our quantifying functions or perform any benchmarks.</p>
<p>As a recurring example, consider passing the column names ‘Timings’ and ‘Data sizes’ along with the data frame returned by the time quantifier: (it consists of those two columns)</p>
<div class="sourceCode" id="cb7"><html><body><pre class="r"><span class="fu"><a href="../reference/asymptoticComplexityClass.html">asymptoticComplexityClass</a></span>(<span class="no">df</span>, <span class="kw">output.size</span> <span class="kw">=</span> <span class="st">"Timings"</span>, <span class="kw">data.size</span> <span class="kw">=</span> <span class="st">"Data sizes"</span>)
<span class="co">#&gt; [1] "loglinear"</span></pre></body></html></div>
<p>As expected, it classifies the correct complexity just like <code><a href="../reference/asymptoticTimeComplexityClass.html">asymptoticTimeComplexityClass()</a></code> did, as because the underlying complexity classification procedure is same. Its just that the parameters are customizable, which leads to a wider use-case scenario than just classifying the trend for time/memory cases.</p>
</div>
<div id="testers" class="section level3">
<h3 class="hasAnchor">
<a href="#testers" class="anchor"></a><a href="https://anirban166.github.io/testComplexity/reference/index.html#section-testers">Testers</a>
</h3>
<p>These are the functions used to test the user-provided algorithm against an expected complexity class. They can be used to verify the theoretically derived or empirically observed complexities either directly or by disregarding the remaining complexity classes to prove the same via contradiction.</p>
<p>There are three surface level functions meant for the user, namely <code><a href="../reference/expect_linear_time.html">expect_linear_time()</a></code>, <code><a href="../reference/expect_loglinear_time.html">expect_loglinear_time()</a></code> and <code><a href="../reference/expect_quadratic_time.html">expect_quadratic_time()</a></code>, all of which as their respective names suggest can be used to test an algorithm against the named complexity class. If the algorithm shows the expected complexity, it doesn’t throw any error. Otherwise a complexity mismatch error is thrown with a traceback from the calling point to the inner functions. Other complexity classes such as <code>constant</code> and <code>log</code> were not taken into account for the moment since these three tend to cover all cases for our test functions. Also note that variants of these functions for dealing with memory have not been implemented since they are not a part of the base objective plus for the fact that the memory quantifier deals with memory <em>allocations</em> at the moment, and might not be fit for all cases.</p>
<p>These functions accept the same parameters as the ones used in <code><a href="../reference/asymptoticTimings.html">asymptoticTimings()</a></code>, so they provide a suitable alternative to the user in place of using the time quantifier and complexity classifier in conjunction.</p>
<p>As an example, lets take our function <code>PeakSegPDPA()</code> and test it against different complexity classes: <br></p>
<div class="sourceCode" id="cb8"><html><body><pre class="r"><span class="fu"><a href="../reference/expect_loglinear_time.html">expect_loglinear_time</a></span>({
<span class="no">data.vec</span> <span class="kw">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Poisson.html">rpois</a></span>(<span class="no">N</span>, <span class="fl">1</span>)
<span class="kw pkg">PeakSegOptimal</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/PeakSegOptimal/man/PeakSegPDPA.html">PeakSegPDPA</a></span>(<span class="no">data.vec</span>, <span class="kw">max.segments</span> <span class="kw">=</span> <span class="fl">3L</span>)}, <span class="kw">data.sizes</span> <span class="kw">=</span> <span class="fl">10</span>^<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fl">4</span>, <span class="kw">by</span> <span class="kw">=</span> <span class="fl">0.5</span>))
<span class="co"># or:</span>
<span class="co"># expect_loglinear_time(PeakSegOptimal::PeakSegPDPA(rpois(N, 1), max.segments = 3L), data.sizes = 10^seq(1, 4, by = 0.5))</span>
<span class="co">#&gt; [1] "loglinear"</span></pre></body></html></div>
<p>The above function throws no error, which means that our algorithm does follow a log-linear trend. On the other hand, if we test for the same against the linear or quadratic variants, we would get errors: (as expected) <br></p>
<div class="sourceCode" id="cb9"><html><body><pre class="r">expect_linear_time({
data.vec &lt;- rpois(N, 1)
PeakSegOptimal::PeakSegPDPA(data.vec, max.segments = 3L)}, data.sizes = 10^seq(1, 4, by = 0.5))
})
#&gt; [1] "loglinear"
#&gt; Error: Complexity mismatch: Expected linear complexity, instead of the predicted loglinear complexity from asymptoticTimeComplexityClass(timings.df). </pre></body></html></div>
<div class="sourceCode" id="cb10"><html><body><pre class="r">expect_quadratic_time({
data.vec &lt;- rpois(N, 1)
PeakSegOptimal::PeakSegPDPA(data.vec, max.segments = 3L)}, data.sizes = 10^seq(1, 4, by = 0.5))
})
#&gt; [1] "loglinear"
#&gt; Error: Complexity mismatch: Expected quadratic complexity, instead of the predicted loglinear complexity from asymptoticTimeComplexityClass(timings.df). </pre></body></html></div>
<p>The call stack (sequence of calls that lead to the error) is returned via a call to <code><a href="https://rdrr.io/r/base/traceback.html">traceback()</a></code> as well, although the user doesn’t need to exemplify the verification through that, since the error message itself clearly states the inequality between the expected and predicted complexity classes, which can be used to prove by contradiction.</p>
</div>
<div id="plotters" class="section level3">
<h3 class="hasAnchor">
<a href="#plotters" class="anchor"></a><a href="https://anirban166.github.io/testComplexity/reference/index.html#section-plotters">Plotters</a>
</h3>
<p>These functions are for plotting the metrics returned by the quantifiers, in case the user still prefers to diagnose the obtained complexity result via the traditional method, i.e. with a visual representation of the benchmarked data.</p>
<p>Considering the columns from the data frames returned by the quantiftying functions, the user can create plots for ‘Timings’ vs ‘Data sizes’ via <code><a href="../reference/plotTimings.html">plotTimings()</a></code> and for ‘Memory usage’ vs ‘Data sizes’ via <code><a href="../reference/plotMemoryUsage.html">plotMemoryUsage()</a></code>: <br></p>
<div class="sourceCode" id="cb11"><html><body><pre class="r"><span class="co"># Plot the trend between benchmarked timings and data sizes:</span>
<span class="no">df.time</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/asymptoticTimings.html">asymptoticTimings</a></span>(<span class="kw pkg">PeakSegOptimal</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/PeakSegOptimal/man/PeakSegPDPA.html">PeakSegPDPA</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/Poisson.html">rpois</a></span>(<span class="no">N</span>, <span class="fl">1</span>), <span class="kw">max.segments</span> <span class="kw">=</span> <span class="fl">3L</span>), <span class="kw">data.sizes</span> <span class="kw">=</span> <span class="fl">10</span>^<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fl">4</span>, <span class="kw">by</span> <span class="kw">=</span> <span class="fl">0.5</span>))
<span class="no">time.plot</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/plotTimings.html">plotTimings</a></span>(<span class="no">df.time</span>, <span class="kw">titles</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="st">"Timings plot"</span>, <span class="st">"PeakSegOptimal::PeakSegPDPA"</span>), <span class="kw">labels</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="st">"Data size"</span>, <span class="st">"Runtime (in nanoseconds)"</span>), <span class="kw">point.color</span> <span class="kw">=</span> <span class="st">"black"</span>, <span class="kw">line.color</span> <span class="kw">=</span> <span class="st">"#9c9494"</span>, <span class="kw">point.size</span> <span class="kw">=</span> <span class="fl">1.6</span>, <span class="kw">line.size</span> <span class="kw">=</span> <span class="fl">1.2</span>)</pre></body></html></div>
<div class="sourceCode" id="cb12"><html><body><pre class="r"><span class="co"># Plot the trend between computed memory allocations vs data sizes:</span>
<span class="no">df.memory</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/asymptoticMemoryUsage.html">asymptoticMemoryUsage</a></span>(<span class="kw pkg">PeakSegOptimal</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/PeakSegOptimal/man/PeakSegPDPA.html">PeakSegPDPA</a></span>(<span class="fu"><a href="https://rdrr.io/r/stats/Poisson.html">rpois</a></span>(<span class="no">N</span>, <span class="fl">1</span>), <span class="kw">max.segments</span> <span class="kw">=</span> <span class="fl">3L</span>), <span class="kw">data.sizes</span> <span class="kw">=</span> <span class="fl">10</span>^<span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span>(<span class="fl">1</span>, <span class="fl">4</span>, <span class="kw">by</span> <span class="kw">=</span> <span class="fl">0.1</span>))
<span class="no">memory.plot</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/plotMemoryUsage.html">plotMemoryUsage</a></span>(<span class="no">df.memory</span>, <span class="kw">titles</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="st">"Memory usage plot"</span>, <span class="st">"PeakSegOptimal::PeakSegPDPA"</span>), <span class="kw">labels</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="st">"Data size"</span>, <span class="st">"Memory size (in bytes)"</span>), <span class="kw">point.alpha</span> <span class="kw">=</span> <span class="fl">1</span>, <span class="kw">line.alpha</span> <span class="kw">=</span> <span class="fl">0.8</span>, <span class="kw">point.color</span> <span class="kw">=</span> <span class="st">"#000000"</span>, <span class="kw">line.color</span> <span class="kw">=</span> <span class="st">"#9c9494"</span>, <span class="kw">point.size</span> <span class="kw">=</span> <span class="fl">2</span>, <span class="kw">line.size</span> <span class="kw">=</span> <span class="fl">1</span>)</pre></body></html></div>
<div class="sourceCode" id="cb13"><html><body><pre class="r"><span class="kw pkg">gridExtra</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/gridExtra/man/arrangeGrob.html">grid.arrange</a></span>(<span class="no">time.plot</span>, <span class="no">memory.plot</span>, <span class="kw">ncol</span> <span class="kw">=</span> <span class="fl">2</span>)</pre></body></html></div>
<p><img src="https://raw.githubusercontent.com/Anirban166/testComplexity/master/Images/PDPAtimememoryWT.png"><!-- --></p>
<p>Themes can be directly appended to the ggplot object returned by the plotters:</p>
<div class="sourceCode" id="cb14"><html><body><pre class="r"><span class="no">time.plot</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/plotTimings.html">plotTimings</a></span>(<span class="no">df.time</span>, <span class="kw">titles</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="st">"Timings plot"</span>, <span class="st">"PeakSegOptimal::PeakSegPDPA"</span>), <span class="kw">labels</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="st">"Data size"</span>, <span class="st">"Runtime (in nanoseconds)"</span>), <span class="kw">point.color</span> <span class="kw">=</span> <span class="st">"#ffec1b"</span>, <span class="kw">line.color</span> <span class="kw">=</span> <span class="st">"#ffec1b"</span>, <span class="kw">point.size</span> <span class="kw">=</span> <span class="fl">1.5</span>, <span class="kw">line.size</span> <span class="kw">=</span> <span class="fl">1.1</span>)
<span class="no">memory.plot</span> <span class="kw">&lt;-</span> <span class="fu"><a href="../reference/plotMemoryUsage.html">plotMemoryUsage</a></span>(<span class="no">df.memory</span>, <span class="kw">titles</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="st">"Memory usage plot"</span>, <span class="st">"PeakSegOptimal::PeakSegPDPA"</span>), <span class="kw">labels</span> <span class="kw">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span>(<span class="st">"Data size"</span>, <span class="st">"Memory size (in bytes)"</span>), <span class="kw">point.alpha</span> <span class="kw">=</span> <span class="fl">1</span>, <span class="kw">line.alpha</span> <span class="kw">=</span> <span class="fl">0.8</span>, <span class="kw">point.color</span> <span class="kw">=</span> <span class="st">"#ffec1b"</span>, <span class="kw">line.color</span> <span class="kw">=</span> <span class="st">"#ffec1b"</span>, <span class="kw">point.size</span> <span class="kw">=</span> <span class="fl">2</span>, <span class="kw">line.size</span> <span class="kw">=</span> <span class="fl">1</span>)</pre></body></html></div>
<div class="sourceCode" id="cb15"><html><body><pre class="r"><span class="no">themed.time.plot</span> <span class="kw">&lt;-</span> <span class="no">time.plot</span> + <span class="kw pkg">hrbrthemes</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/hrbrthemes/man/theme_ipsum_rc.html">theme_ft_rc</a></span>()
<span class="no">themed.memory.plot</span> <span class="kw">&lt;-</span> <span class="no">memory.plot</span> + <span class="kw pkg">hrbrthemes</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/hrbrthemes/man/theme_ipsum_rc.html">theme_ft_rc</a></span>()</pre></body></html></div>
<div class="sourceCode" id="cb16"><html><body><pre class="r"><span class="kw pkg">gridExtra</span><span class="kw ns">::</span><span class="fu"><a href="https://rdrr.io/pkg/gridExtra/man/arrangeGrob.html">grid.arrange</a></span>(<span class="no">themed.time.plot</span>, <span class="no">themed.memory.plot</span>, <span class="kw">ncol</span> <span class="kw">=</span> <span class="fl">2</span>)</pre></body></html></div>
<p><img src="https://raw.githubusercontent.com/Anirban166/testComplexity/master/Images/PDPAtimememoryPT.png"><!-- --></p>
<p>For the users relatively new to such diagnostic plots for benchmarking/profiling, it might seem hard to figure the trend just by looking at such individual plots. By testing with more functions, the graphical trends for the complexity classes become more clearly distinguishable over time. But for a quicker alternative, comparison plots can be created. For instance, the function we considered in our examples here (<code>PeakSegPDPA()</code>) follows a log-linear trend (as proven above), so we can consider another function with either a lower or higher complexity class, and test for our function’s plot-line to be above or lower respectively. As an example, consider comparing the trends in timings versus data sizes of <code><a href="https://rdrr.io/pkg/PeakSegOptimal/man/PeakSegPDPA.html">PeakSegOptimal::PeakSegPDPA()</a></code> with the function <a href="https://github.com/tdhock/PeakSegDP/blob/master/R/cDPA.R"><code><a href="https://rdrr.io/pkg/PeakSegDP/man/cDPA.html">PeakSegDP::cDPA()</a></code></a>, which is <a href="https://anirban166.github.io/testComplexity/articles/cDPA.html">found</a> to be quadratic in nature: <br></p>
<p><img src="https://raw.githubusercontent.com/Anirban166/testComplexity/master/Images/cDPAvsPeakSegPDPA.png"><!-- --></p>
<p>By observing the above figure, the user can tell that <code>PeakSegPDPA()</code> would fall in a lower complexity class in comparison to <code>cDPA()</code> (provided we know the later follows a quadratic trend), with the difference scaling asymptotically. However, it might not be clear whether it falls in the log-linear or linear zone by just looking at this comparison, (visually diagnosing a distinct complexity class from benchmarked data is difficult) which is the reason why our package thrives to provide a much more convenient alternative via the use of testers and complexity classifiers (operating on data supplied from the quantifiers).</p>
<p>Without this added convenience or a good visual diagnosis capability, the user may need to prepare a seperate comparison plot considering all the complexities (with glm-mapped values for instance) along with the required algorithm to figure the resultant complexity class. As an example, such a plot for our taken algorithm with regression based plotlines (considering runtime values at the extremities) would look like: <br></p>
<p><img src="https://raw.githubusercontent.com/Anirban166/testComplexity/master/Images/ComplexitiesVSPeakSegPDPA.png"><!-- --></p>
<p>It is clear that our algorithm <code>PeakSegPDPA()</code> follows a log-linear asymptotic trend as can be observed from the above plot, with the plotline for the function being in close proximity to (or having the least deviation from) the log-linear line.</p>
<hr>
<p>That sums up the functionality offered by testComplexity <code>0.0.0.9000</code>. For more examples, please check the articles section from the navigation bar of the <a href="https://anirban166.github.io/testComplexity/">website</a>.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Anirban Chetia.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.1.</p>
</div>

      </footer>
</div>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.1/docsearch.min.js" integrity="sha256-GKvGqXDznoRYHCwKXGnuchvKSwmx9SRMrZOTh2g4Sb0=" crossorigin="anonymous"></script><script>
  docsearch({
    
    
    apiKey: 'd84f81326b636909ead6500a3882606c',
    indexName: 'testcomplexity',
    inputSelector: 'input#search-input.form-control',
    transformData: function(hits) {
      return hits.map(function (hit) {
        hit.url = updateHitURL(hit);
        return hit;
      });
    }
  });
</script>
</body>
</html>
